//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export interface IAuthorClient {
    /**
     * @return OK
     */
    authorGet(): Promise<AuthorDto[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    authorPost(body?: AuthorCreateDto | undefined): Promise<AuthorDto>;
    /**
     * @return OK
     */
    authorGet(id: string): Promise<AuthorDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    authorPut(id: string, body?: AuthorUpdateDto | undefined): Promise<void>;
    /**
     * @return OK
     */
    authorDelete(id: string): Promise<void>;
}

export class AuthorClient implements IAuthorClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return OK
     */
    authorGet( cancelToken?: CancelToken): Promise<AuthorDto[]> {
        let url_ = this.baseUrl + "/api/Author";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthorGet(_response);
        });
    }

    protected processAuthorGet(response: AxiosResponse): Promise<AuthorDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AuthorDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<AuthorDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthorDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    authorPost(body?: AuthorCreateDto | undefined, cancelToken?: CancelToken): Promise<AuthorDto> {
        let url_ = this.baseUrl + "/api/Author";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthorPost(_response);
        });
    }

    protected processAuthorPost(response: AxiosResponse): Promise<AuthorDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthorDto.fromJS(resultData200);
            return Promise.resolve<AuthorDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthorDto>(null as any);
    }

    /**
     * @return OK
     */
    authorGet(id: string, cancelToken?: CancelToken): Promise<AuthorDto> {
        let url_ = this.baseUrl + "/api/Author/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthorGet(_response);
        });
    }

    protected processAuthorGet(response: AxiosResponse): Promise<AuthorDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthorDto.fromJS(resultData200);
            return Promise.resolve<AuthorDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthorDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    authorPut(id: string, body?: AuthorUpdateDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Author/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthorPut(_response);
        });
    }

    protected processAuthorPut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    authorDelete(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Author/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthorDelete(_response);
        });
    }

    protected processAuthorDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IBooksClient {
    /**
     * @return OK
     */
    booksGet(): Promise<BookDto[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    booksPost(body?: BookCreateDto | undefined): Promise<BookDto>;
    /**
     * @return OK
     */
    booksGet(id: string): Promise<BookDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    booksPut(id: string, body?: BookUpdateDto | undefined): Promise<BookDto>;
    /**
     * @return OK
     */
    booksDelete(id: string): Promise<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    position(id: string, body?: BookPositionDto | undefined): Promise<BookDto>;
}

export class BooksClient implements IBooksClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return OK
     */
    booksGet( cancelToken?: CancelToken): Promise<BookDto[]> {
        let url_ = this.baseUrl + "/api/Books";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBooksGet(_response);
        });
    }

    protected processBooksGet(response: AxiosResponse): Promise<BookDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BookDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<BookDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BookDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    booksPost(body?: BookCreateDto | undefined, cancelToken?: CancelToken): Promise<BookDto> {
        let url_ = this.baseUrl + "/api/Books";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBooksPost(_response);
        });
    }

    protected processBooksPost(response: AxiosResponse): Promise<BookDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BookDto.fromJS(resultData200);
            return Promise.resolve<BookDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BookDto>(null as any);
    }

    /**
     * @return OK
     */
    booksGet(id: string, cancelToken?: CancelToken): Promise<BookDto> {
        let url_ = this.baseUrl + "/api/Books/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBooksGet(_response);
        });
    }

    protected processBooksGet(response: AxiosResponse): Promise<BookDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BookDto.fromJS(resultData200);
            return Promise.resolve<BookDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BookDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    booksPut(id: string, body?: BookUpdateDto | undefined, cancelToken?: CancelToken): Promise<BookDto> {
        let url_ = this.baseUrl + "/api/Books/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBooksPut(_response);
        });
    }

    protected processBooksPut(response: AxiosResponse): Promise<BookDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BookDto.fromJS(resultData200);
            return Promise.resolve<BookDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BookDto>(null as any);
    }

    /**
     * @return OK
     */
    booksDelete(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Books/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBooksDelete(_response);
        });
    }

    protected processBooksDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    position(id: string, body?: BookPositionDto | undefined, cancelToken?: CancelToken): Promise<BookDto> {
        let url_ = this.baseUrl + "/api/Books/{id}/position";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPosition(_response);
        });
    }

    protected processPosition(response: AxiosResponse): Promise<BookDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BookDto.fromJS(resultData200);
            return Promise.resolve<BookDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BookDto>(null as any);
    }
}

export interface IJournalsClient {
    /**
     * @return OK
     */
    journalsGet(): Promise<JournalDto[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    journalsPost(body?: JournalCreateDto | undefined): Promise<JournalDto>;
    /**
     * @return OK
     */
    journalsGet(id: number): Promise<JournalDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    journalsPut(id: number, body?: JournalUpdateDto | undefined): Promise<void>;
    /**
     * @return OK
     */
    journalsDelete(id: number): Promise<void>;
    /**
     * @param query (optional) 
     * @return OK
     */
    search(query?: string | undefined): Promise<JournalDto[]>;
    /**
     * @return OK
     */
    category(category: JournalCategory): Promise<JournalDto[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    position(id: number, body?: JournalPositionDto | undefined): Promise<JournalDto>;
}

export class JournalsClient implements IJournalsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return OK
     */
    journalsGet( cancelToken?: CancelToken): Promise<JournalDto[]> {
        let url_ = this.baseUrl + "/api/Journals";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processJournalsGet(_response);
        });
    }

    protected processJournalsGet(response: AxiosResponse): Promise<JournalDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JournalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<JournalDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JournalDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    journalsPost(body?: JournalCreateDto | undefined, cancelToken?: CancelToken): Promise<JournalDto> {
        let url_ = this.baseUrl + "/api/Journals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processJournalsPost(_response);
        });
    }

    protected processJournalsPost(response: AxiosResponse): Promise<JournalDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JournalDto.fromJS(resultData200);
            return Promise.resolve<JournalDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JournalDto>(null as any);
    }

    /**
     * @return OK
     */
    journalsGet(id: number, cancelToken?: CancelToken): Promise<JournalDto> {
        let url_ = this.baseUrl + "/api/Journals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processJournalsGet(_response);
        });
    }

    protected processJournalsGet(response: AxiosResponse): Promise<JournalDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JournalDto.fromJS(resultData200);
            return Promise.resolve<JournalDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JournalDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    journalsPut(id: number, body?: JournalUpdateDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Journals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processJournalsPut(_response);
        });
    }

    protected processJournalsPut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    journalsDelete(id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Journals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processJournalsDelete(_response);
        });
    }

    protected processJournalsDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param query (optional) 
     * @return OK
     */
    search(query?: string | undefined, cancelToken?: CancelToken): Promise<JournalDto[]> {
        let url_ = this.baseUrl + "/api/Journals/search?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: AxiosResponse): Promise<JournalDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JournalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<JournalDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JournalDto[]>(null as any);
    }

    /**
     * @return OK
     */
    category(category: JournalCategory, cancelToken?: CancelToken): Promise<JournalDto[]> {
        let url_ = this.baseUrl + "/api/Journals/category/{category}";
        if (category === undefined || category === null)
            throw new Error("The parameter 'category' must be defined.");
        url_ = url_.replace("{category}", encodeURIComponent("" + category));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCategory(_response);
        });
    }

    protected processCategory(response: AxiosResponse): Promise<JournalDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(JournalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<JournalDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JournalDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    position(id: number, body?: JournalPositionDto | undefined, cancelToken?: CancelToken): Promise<JournalDto> {
        let url_ = this.baseUrl + "/api/Journals/{id}/position";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPosition(_response);
        });
    }

    protected processPosition(response: AxiosResponse): Promise<JournalDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JournalDto.fromJS(resultData200);
            return Promise.resolve<JournalDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JournalDto>(null as any);
    }
}

export interface IReservationClient {
    /**
     * @return OK
     */
    reservationGet(): Promise<ReservationDto[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    reservationPost(body?: ReservationCreateDto | undefined): Promise<ReservationDto>;
    /**
     * @return OK
     */
    reservationGet(id: string): Promise<ReservationDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    reservationPut(id: string, body?: ReservationUpdateDto | undefined): Promise<void>;
    /**
     * @return OK
     */
    reservationDelete(id: string): Promise<void>;
}

export class ReservationClient implements IReservationClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return OK
     */
    reservationGet( cancelToken?: CancelToken): Promise<ReservationDto[]> {
        let url_ = this.baseUrl + "/api/Reservation";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReservationGet(_response);
        });
    }

    protected processReservationGet(response: AxiosResponse): Promise<ReservationDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReservationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ReservationDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReservationDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    reservationPost(body?: ReservationCreateDto | undefined, cancelToken?: CancelToken): Promise<ReservationDto> {
        let url_ = this.baseUrl + "/api/Reservation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReservationPost(_response);
        });
    }

    protected processReservationPost(response: AxiosResponse): Promise<ReservationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReservationDto.fromJS(resultData200);
            return Promise.resolve<ReservationDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReservationDto>(null as any);
    }

    /**
     * @return OK
     */
    reservationGet(id: string, cancelToken?: CancelToken): Promise<ReservationDto> {
        let url_ = this.baseUrl + "/api/Reservation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReservationGet(_response);
        });
    }

    protected processReservationGet(response: AxiosResponse): Promise<ReservationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReservationDto.fromJS(resultData200);
            return Promise.resolve<ReservationDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReservationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    reservationPut(id: string, body?: ReservationUpdateDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Reservation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReservationPut(_response);
        });
    }

    protected processReservationPut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    reservationDelete(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Reservation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReservationDelete(_response);
        });
    }

    protected processReservationDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IShelfClient {
    /**
     * @return OK
     */
    shelfGet(): Promise<ShelfDto[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    shelfPost(body?: ShelfCreateDto | undefined): Promise<ShelfDto>;
    /**
     * @return OK
     */
    shelfGet(id: number): Promise<ShelfDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    shelfPut(id: number, body?: ShelfUpdateDto | undefined): Promise<void>;
    /**
     * @return OK
     */
    shelfDelete(id: number): Promise<void>;
    /**
     * @param body (optional) 
     * @return OK
     */
    autoPosition(body?: ShelfCreateDto | undefined): Promise<ShelfDto>;
}

export class ShelfClient implements IShelfClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return OK
     */
    shelfGet( cancelToken?: CancelToken): Promise<ShelfDto[]> {
        let url_ = this.baseUrl + "/api/Shelf";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processShelfGet(_response);
        });
    }

    protected processShelfGet(response: AxiosResponse): Promise<ShelfDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ShelfDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ShelfDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ShelfDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    shelfPost(body?: ShelfCreateDto | undefined, cancelToken?: CancelToken): Promise<ShelfDto> {
        let url_ = this.baseUrl + "/api/Shelf";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processShelfPost(_response);
        });
    }

    protected processShelfPost(response: AxiosResponse): Promise<ShelfDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ShelfDto.fromJS(resultData200);
            return Promise.resolve<ShelfDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ShelfDto>(null as any);
    }

    /**
     * @return OK
     */
    shelfGet(id: number, cancelToken?: CancelToken): Promise<ShelfDto> {
        let url_ = this.baseUrl + "/api/Shelf/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processShelfGet(_response);
        });
    }

    protected processShelfGet(response: AxiosResponse): Promise<ShelfDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ShelfDto.fromJS(resultData200);
            return Promise.resolve<ShelfDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ShelfDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    shelfPut(id: number, body?: ShelfUpdateDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Shelf/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processShelfPut(_response);
        });
    }

    protected processShelfPut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    shelfDelete(id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/Shelf/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processShelfDelete(_response);
        });
    }

    protected processShelfDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    autoPosition(body?: ShelfCreateDto | undefined, cancelToken?: CancelToken): Promise<ShelfDto> {
        let url_ = this.baseUrl + "/api/Shelf/auto-position";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAutoPosition(_response);
        });
    }

    protected processAutoPosition(response: AxiosResponse): Promise<ShelfDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ShelfDto.fromJS(resultData200);
            return Promise.resolve<ShelfDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ShelfDto>(null as any);
    }
}

export interface IUserClient {
    /**
     * @return OK
     */
    userGet(): Promise<UserDto[]>;
    /**
     * @param body (optional) 
     * @return OK
     */
    userPost(body?: UserCreateDto | undefined): Promise<UserDto>;
    /**
     * @return OK
     */
    userGet(id: string): Promise<UserDto>;
    /**
     * @param body (optional) 
     * @return OK
     */
    userPut(id: string, body?: UserUpdateDto | undefined): Promise<void>;
    /**
     * @return OK
     */
    userDelete(id: string): Promise<void>;
}

export class UserClient implements IUserClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * @return OK
     */
    userGet( cancelToken?: CancelToken): Promise<UserDto[]> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserGet(_response);
        });
    }

    protected processUserGet(response: AxiosResponse): Promise<UserDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<UserDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    userPost(body?: UserCreateDto | undefined, cancelToken?: CancelToken): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserPost(_response);
        });
    }

    protected processUserPost(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @return OK
     */
    userGet(id: string, cancelToken?: CancelToken): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserGet(_response);
        });
    }

    protected processUserGet(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    userPut(id: string, body?: UserUpdateDto | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserPut(_response);
        });
    }

    protected processUserPut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    userDelete(id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUserDelete(_response);
        });
    }

    protected processUserDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = (response as any).response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AuthorCreateDto implements IAuthorCreateDto {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    dateOfDeath?: Date | undefined;
    biography?: string | undefined;
    nationality?: string | undefined;

    constructor(data?: IAuthorCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.dateOfDeath = _data["dateOfDeath"] ? new Date(_data["dateOfDeath"].toString()) : <any>undefined;
            this.biography = _data["biography"];
            this.nationality = _data["nationality"];
        }
    }

    static fromJS(data: any): AuthorCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["dateOfDeath"] = this.dateOfDeath ? this.dateOfDeath.toISOString() : <any>undefined;
        data["biography"] = this.biography;
        data["nationality"] = this.nationality;
        return data;
    }
}

export interface IAuthorCreateDto {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    dateOfDeath?: Date | undefined;
    biography?: string | undefined;
    nationality?: string | undefined;
}

export class AuthorDto implements IAuthorDto {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    dateOfDeath?: Date | undefined;
    biography?: string | undefined;
    nationality?: string | undefined;

    constructor(data?: IAuthorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.dateOfDeath = _data["dateOfDeath"] ? new Date(_data["dateOfDeath"].toString()) : <any>undefined;
            this.biography = _data["biography"];
            this.nationality = _data["nationality"];
        }
    }

    static fromJS(data: any): AuthorDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["dateOfDeath"] = this.dateOfDeath ? this.dateOfDeath.toISOString() : <any>undefined;
        data["biography"] = this.biography;
        data["nationality"] = this.nationality;
        return data;
    }
}

export interface IAuthorDto {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    dateOfDeath?: Date | undefined;
    biography?: string | undefined;
    nationality?: string | undefined;
}

export class AuthorUpdateDto implements IAuthorUpdateDto {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    dateOfDeath?: Date | undefined;
    biography?: string | undefined;
    nationality?: string | undefined;

    constructor(data?: IAuthorUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.dateOfDeath = _data["dateOfDeath"] ? new Date(_data["dateOfDeath"].toString()) : <any>undefined;
            this.biography = _data["biography"];
            this.nationality = _data["nationality"];
        }
    }

    static fromJS(data: any): AuthorUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["dateOfDeath"] = this.dateOfDeath ? this.dateOfDeath.toISOString() : <any>undefined;
        data["biography"] = this.biography;
        data["nationality"] = this.nationality;
        return data;
    }
}

export interface IAuthorUpdateDto {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    dateOfDeath?: Date | undefined;
    biography?: string | undefined;
    nationality?: string | undefined;
}

export class BookCreateDto implements IBookCreateDto {
    title!: string;
    authors?: string | undefined;
    genre?: string | undefined;
    categorization?: string | undefined;
    udk?: string | undefined;
    bbk?: string | undefined;
    isbn?: string | undefined;
    cover?: string | undefined;
    description?: string | undefined;
    summary?: string | undefined;
    publicationYear?: number | undefined;
    publisher?: string | undefined;
    pageCount?: number | undefined;
    language?: string | undefined;
    availableCopies?: number;
    edition?: string | undefined;
    price?: number | undefined;
    format?: string | undefined;
    originalTitle?: string | undefined;
    originalLanguage?: string | undefined;
    isEbook?: boolean | undefined;
    condition?: string | undefined;
    shelfId?: number | undefined;

    constructor(data?: IBookCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.authors = _data["authors"];
            this.genre = _data["genre"];
            this.categorization = _data["categorization"];
            this.udk = _data["udk"];
            this.bbk = _data["bbk"];
            this.isbn = _data["isbn"];
            this.cover = _data["cover"];
            this.description = _data["description"];
            this.summary = _data["summary"];
            this.publicationYear = _data["publicationYear"];
            this.publisher = _data["publisher"];
            this.pageCount = _data["pageCount"];
            this.language = _data["language"];
            this.availableCopies = _data["availableCopies"];
            this.edition = _data["edition"];
            this.price = _data["price"];
            this.format = _data["format"];
            this.originalTitle = _data["originalTitle"];
            this.originalLanguage = _data["originalLanguage"];
            this.isEbook = _data["isEbook"];
            this.condition = _data["condition"];
            this.shelfId = _data["shelfId"];
        }
    }

    static fromJS(data: any): BookCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["authors"] = this.authors;
        data["genre"] = this.genre;
        data["categorization"] = this.categorization;
        data["udk"] = this.udk;
        data["bbk"] = this.bbk;
        data["isbn"] = this.isbn;
        data["cover"] = this.cover;
        data["description"] = this.description;
        data["summary"] = this.summary;
        data["publicationYear"] = this.publicationYear;
        data["publisher"] = this.publisher;
        data["pageCount"] = this.pageCount;
        data["language"] = this.language;
        data["availableCopies"] = this.availableCopies;
        data["edition"] = this.edition;
        data["price"] = this.price;
        data["format"] = this.format;
        data["originalTitle"] = this.originalTitle;
        data["originalLanguage"] = this.originalLanguage;
        data["isEbook"] = this.isEbook;
        data["condition"] = this.condition;
        data["shelfId"] = this.shelfId;
        return data;
    }
}

export interface IBookCreateDto {
    title: string;
    authors?: string | undefined;
    genre?: string | undefined;
    categorization?: string | undefined;
    udk?: string | undefined;
    bbk?: string | undefined;
    isbn?: string | undefined;
    cover?: string | undefined;
    description?: string | undefined;
    summary?: string | undefined;
    publicationYear?: number | undefined;
    publisher?: string | undefined;
    pageCount?: number | undefined;
    language?: string | undefined;
    availableCopies?: number;
    edition?: string | undefined;
    price?: number | undefined;
    format?: string | undefined;
    originalTitle?: string | undefined;
    originalLanguage?: string | undefined;
    isEbook?: boolean | undefined;
    condition?: string | undefined;
    shelfId?: number | undefined;
}

export class BookDto implements IBookDto {
    id?: string;
    title?: string | undefined;
    authors?: string | undefined;
    genre?: string | undefined;
    categorization?: string | undefined;
    udk?: string | undefined;
    bbk?: string | undefined;
    isbn?: string | undefined;
    cover?: string | undefined;
    description?: string | undefined;
    summary?: string | undefined;
    publicationYear?: number | undefined;
    publisher?: string | undefined;
    pageCount?: number | undefined;
    language?: string | undefined;
    availableCopies?: number;
    dateAdded?: Date;
    dateModified?: Date;
    edition?: string | undefined;
    price?: number | undefined;
    format?: string | undefined;
    originalTitle?: string | undefined;
    originalLanguage?: string | undefined;
    dateRead?: Date | undefined;
    isEbook?: boolean | undefined;
    condition?: string | undefined;
    shelfId?: number | undefined;
    readonly position?: number;

    constructor(data?: IBookDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.authors = _data["authors"];
            this.genre = _data["genre"];
            this.categorization = _data["categorization"];
            this.udk = _data["udk"];
            this.bbk = _data["bbk"];
            this.isbn = _data["isbn"];
            this.cover = _data["cover"];
            this.description = _data["description"];
            this.summary = _data["summary"];
            this.publicationYear = _data["publicationYear"];
            this.publisher = _data["publisher"];
            this.pageCount = _data["pageCount"];
            this.language = _data["language"];
            this.availableCopies = _data["availableCopies"];
            this.dateAdded = _data["dateAdded"] ? new Date(_data["dateAdded"].toString()) : <any>undefined;
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.edition = _data["edition"];
            this.price = _data["price"];
            this.format = _data["format"];
            this.originalTitle = _data["originalTitle"];
            this.originalLanguage = _data["originalLanguage"];
            this.dateRead = _data["dateRead"] ? new Date(_data["dateRead"].toString()) : <any>undefined;
            this.isEbook = _data["isEbook"];
            this.condition = _data["condition"];
            this.shelfId = _data["shelfId"];
            (<any>this).position = _data["position"];
        }
    }

    static fromJS(data: any): BookDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["authors"] = this.authors;
        data["genre"] = this.genre;
        data["categorization"] = this.categorization;
        data["udk"] = this.udk;
        data["bbk"] = this.bbk;
        data["isbn"] = this.isbn;
        data["cover"] = this.cover;
        data["description"] = this.description;
        data["summary"] = this.summary;
        data["publicationYear"] = this.publicationYear;
        data["publisher"] = this.publisher;
        data["pageCount"] = this.pageCount;
        data["language"] = this.language;
        data["availableCopies"] = this.availableCopies;
        data["dateAdded"] = this.dateAdded ? this.dateAdded.toISOString() : <any>undefined;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["edition"] = this.edition;
        data["price"] = this.price;
        data["format"] = this.format;
        data["originalTitle"] = this.originalTitle;
        data["originalLanguage"] = this.originalLanguage;
        data["dateRead"] = this.dateRead ? this.dateRead.toISOString() : <any>undefined;
        data["isEbook"] = this.isEbook;
        data["condition"] = this.condition;
        data["shelfId"] = this.shelfId;
        data["position"] = this.position;
        return data;
    }
}

export interface IBookDto {
    id?: string;
    title?: string | undefined;
    authors?: string | undefined;
    genre?: string | undefined;
    categorization?: string | undefined;
    udk?: string | undefined;
    bbk?: string | undefined;
    isbn?: string | undefined;
    cover?: string | undefined;
    description?: string | undefined;
    summary?: string | undefined;
    publicationYear?: number | undefined;
    publisher?: string | undefined;
    pageCount?: number | undefined;
    language?: string | undefined;
    availableCopies?: number;
    dateAdded?: Date;
    dateModified?: Date;
    edition?: string | undefined;
    price?: number | undefined;
    format?: string | undefined;
    originalTitle?: string | undefined;
    originalLanguage?: string | undefined;
    dateRead?: Date | undefined;
    isEbook?: boolean | undefined;
    condition?: string | undefined;
    shelfId?: number | undefined;
    position?: number;
}

export class BookPositionDto implements IBookPositionDto {
    shelfId!: number;
    position!: number;

    constructor(data?: IBookPositionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shelfId = _data["shelfId"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): BookPositionDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookPositionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shelfId"] = this.shelfId;
        data["position"] = this.position;
        return data;
    }
}

export interface IBookPositionDto {
    shelfId: number;
    position: number;
}

export class BookUpdateDto implements IBookUpdateDto {
    title!: string;
    authors?: string | undefined;
    genre?: string | undefined;
    categorization?: string | undefined;
    udk?: string | undefined;
    bbk?: string | undefined;
    isbn?: string | undefined;
    cover?: string | undefined;
    description?: string | undefined;
    summary?: string | undefined;
    publicationYear?: number | undefined;
    publisher?: string | undefined;
    pageCount?: number | undefined;
    language?: string | undefined;
    availableCopies?: number;
    edition?: string | undefined;
    price?: number | undefined;
    format?: string | undefined;
    originalTitle?: string | undefined;
    originalLanguage?: string | undefined;
    isEbook?: boolean | undefined;
    condition?: string | undefined;
    shelfId?: number | undefined;

    constructor(data?: IBookUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.authors = _data["authors"];
            this.genre = _data["genre"];
            this.categorization = _data["categorization"];
            this.udk = _data["udk"];
            this.bbk = _data["bbk"];
            this.isbn = _data["isbn"];
            this.cover = _data["cover"];
            this.description = _data["description"];
            this.summary = _data["summary"];
            this.publicationYear = _data["publicationYear"];
            this.publisher = _data["publisher"];
            this.pageCount = _data["pageCount"];
            this.language = _data["language"];
            this.availableCopies = _data["availableCopies"];
            this.edition = _data["edition"];
            this.price = _data["price"];
            this.format = _data["format"];
            this.originalTitle = _data["originalTitle"];
            this.originalLanguage = _data["originalLanguage"];
            this.isEbook = _data["isEbook"];
            this.condition = _data["condition"];
            this.shelfId = _data["shelfId"];
        }
    }

    static fromJS(data: any): BookUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new BookUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["authors"] = this.authors;
        data["genre"] = this.genre;
        data["categorization"] = this.categorization;
        data["udk"] = this.udk;
        data["bbk"] = this.bbk;
        data["isbn"] = this.isbn;
        data["cover"] = this.cover;
        data["description"] = this.description;
        data["summary"] = this.summary;
        data["publicationYear"] = this.publicationYear;
        data["publisher"] = this.publisher;
        data["pageCount"] = this.pageCount;
        data["language"] = this.language;
        data["availableCopies"] = this.availableCopies;
        data["edition"] = this.edition;
        data["price"] = this.price;
        data["format"] = this.format;
        data["originalTitle"] = this.originalTitle;
        data["originalLanguage"] = this.originalLanguage;
        data["isEbook"] = this.isEbook;
        data["condition"] = this.condition;
        data["shelfId"] = this.shelfId;
        return data;
    }
}

export interface IBookUpdateDto {
    title: string;
    authors?: string | undefined;
    genre?: string | undefined;
    categorization?: string | undefined;
    udk?: string | undefined;
    bbk?: string | undefined;
    isbn?: string | undefined;
    cover?: string | undefined;
    description?: string | undefined;
    summary?: string | undefined;
    publicationYear?: number | undefined;
    publisher?: string | undefined;
    pageCount?: number | undefined;
    language?: string | undefined;
    availableCopies?: number;
    edition?: string | undefined;
    price?: number | undefined;
    format?: string | undefined;
    originalTitle?: string | undefined;
    originalLanguage?: string | undefined;
    isEbook?: boolean | undefined;
    condition?: string | undefined;
    shelfId?: number | undefined;
}

export enum JournalCategory {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class JournalCreateDto implements IJournalCreateDto {
    id?: number;
    title?: string | undefined;
    issn?: string | undefined;
    registrationNumber?: string | undefined;
    format?: string | undefined;
    periodicity?: string | undefined;
    pagesPerIssue?: number | undefined;
    description?: string | undefined;
    publisher?: string | undefined;
    foundationDate?: Date | undefined;
    circulation?: number | undefined;
    isOpenAccess?: boolean;
    category?: string | undefined;
    targetAudience?: string | undefined;
    isPeerReviewed?: boolean | undefined;
    isIndexedInRINTS?: boolean | undefined;
    isIndexedInScopus?: boolean | undefined;
    isIndexedInWebOfScience?: boolean | undefined;
    publicationDate?: Date | undefined;
    pageCount?: number | undefined;
    coverImageUrl?: string | undefined;

    constructor(data?: IJournalCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.issn = _data["issn"];
            this.registrationNumber = _data["registrationNumber"];
            this.format = _data["format"];
            this.periodicity = _data["periodicity"];
            this.pagesPerIssue = _data["pagesPerIssue"];
            this.description = _data["description"];
            this.publisher = _data["publisher"];
            this.foundationDate = _data["foundationDate"] ? new Date(_data["foundationDate"].toString()) : <any>undefined;
            this.circulation = _data["circulation"];
            this.isOpenAccess = _data["isOpenAccess"];
            this.category = _data["category"];
            this.targetAudience = _data["targetAudience"];
            this.isPeerReviewed = _data["isPeerReviewed"];
            this.isIndexedInRINTS = _data["isIndexedInRINTS"];
            this.isIndexedInScopus = _data["isIndexedInScopus"];
            this.isIndexedInWebOfScience = _data["isIndexedInWebOfScience"];
            this.publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
            this.pageCount = _data["pageCount"];
            this.coverImageUrl = _data["coverImageUrl"];
        }
    }

    static fromJS(data: any): JournalCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new JournalCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["issn"] = this.issn;
        data["registrationNumber"] = this.registrationNumber;
        data["format"] = this.format;
        data["periodicity"] = this.periodicity;
        data["pagesPerIssue"] = this.pagesPerIssue;
        data["description"] = this.description;
        data["publisher"] = this.publisher;
        data["foundationDate"] = this.foundationDate ? this.foundationDate.toISOString() : <any>undefined;
        data["circulation"] = this.circulation;
        data["isOpenAccess"] = this.isOpenAccess;
        data["category"] = this.category;
        data["targetAudience"] = this.targetAudience;
        data["isPeerReviewed"] = this.isPeerReviewed;
        data["isIndexedInRINTS"] = this.isIndexedInRINTS;
        data["isIndexedInScopus"] = this.isIndexedInScopus;
        data["isIndexedInWebOfScience"] = this.isIndexedInWebOfScience;
        data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
        data["pageCount"] = this.pageCount;
        data["coverImageUrl"] = this.coverImageUrl;
        return data;
    }
}

export interface IJournalCreateDto {
    id?: number;
    title?: string | undefined;
    issn?: string | undefined;
    registrationNumber?: string | undefined;
    format?: string | undefined;
    periodicity?: string | undefined;
    pagesPerIssue?: number | undefined;
    description?: string | undefined;
    publisher?: string | undefined;
    foundationDate?: Date | undefined;
    circulation?: number | undefined;
    isOpenAccess?: boolean;
    category?: string | undefined;
    targetAudience?: string | undefined;
    isPeerReviewed?: boolean | undefined;
    isIndexedInRINTS?: boolean | undefined;
    isIndexedInScopus?: boolean | undefined;
    isIndexedInWebOfScience?: boolean | undefined;
    publicationDate?: Date | undefined;
    pageCount?: number | undefined;
    coverImageUrl?: string | undefined;
}

export class JournalDto implements IJournalDto {
    id?: number;
    title?: string | undefined;
    issn?: string | undefined;
    registrationNumber?: string | undefined;
    format?: string | undefined;
    periodicity?: string | undefined;
    pagesPerIssue?: number | undefined;
    description?: string | undefined;
    publisher?: string | undefined;
    foundationDate?: Date | undefined;
    circulation?: number | undefined;
    isOpenAccess?: boolean;
    category?: string | undefined;
    targetAudience?: string | undefined;
    isPeerReviewed?: boolean | undefined;
    isIndexedInRINTS?: boolean | undefined;
    isIndexedInScopus?: boolean | undefined;
    isIndexedInWebOfScience?: boolean | undefined;
    publicationDate?: Date | undefined;
    pageCount?: number | undefined;
    coverImageUrl?: string | undefined;
    readonly shelfId?: number;
    readonly position?: number;

    constructor(data?: IJournalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.issn = _data["issn"];
            this.registrationNumber = _data["registrationNumber"];
            this.format = _data["format"];
            this.periodicity = _data["periodicity"];
            this.pagesPerIssue = _data["pagesPerIssue"];
            this.description = _data["description"];
            this.publisher = _data["publisher"];
            this.foundationDate = _data["foundationDate"] ? new Date(_data["foundationDate"].toString()) : <any>undefined;
            this.circulation = _data["circulation"];
            this.isOpenAccess = _data["isOpenAccess"];
            this.category = _data["category"];
            this.targetAudience = _data["targetAudience"];
            this.isPeerReviewed = _data["isPeerReviewed"];
            this.isIndexedInRINTS = _data["isIndexedInRINTS"];
            this.isIndexedInScopus = _data["isIndexedInScopus"];
            this.isIndexedInWebOfScience = _data["isIndexedInWebOfScience"];
            this.publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
            this.pageCount = _data["pageCount"];
            this.coverImageUrl = _data["coverImageUrl"];
            (<any>this).shelfId = _data["shelfId"];
            (<any>this).position = _data["position"];
        }
    }

    static fromJS(data: any): JournalDto {
        data = typeof data === 'object' ? data : {};
        let result = new JournalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["issn"] = this.issn;
        data["registrationNumber"] = this.registrationNumber;
        data["format"] = this.format;
        data["periodicity"] = this.periodicity;
        data["pagesPerIssue"] = this.pagesPerIssue;
        data["description"] = this.description;
        data["publisher"] = this.publisher;
        data["foundationDate"] = this.foundationDate ? this.foundationDate.toISOString() : <any>undefined;
        data["circulation"] = this.circulation;
        data["isOpenAccess"] = this.isOpenAccess;
        data["category"] = this.category;
        data["targetAudience"] = this.targetAudience;
        data["isPeerReviewed"] = this.isPeerReviewed;
        data["isIndexedInRINTS"] = this.isIndexedInRINTS;
        data["isIndexedInScopus"] = this.isIndexedInScopus;
        data["isIndexedInWebOfScience"] = this.isIndexedInWebOfScience;
        data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
        data["pageCount"] = this.pageCount;
        data["coverImageUrl"] = this.coverImageUrl;
        data["shelfId"] = this.shelfId;
        data["position"] = this.position;
        return data;
    }
}

export interface IJournalDto {
    id?: number;
    title?: string | undefined;
    issn?: string | undefined;
    registrationNumber?: string | undefined;
    format?: string | undefined;
    periodicity?: string | undefined;
    pagesPerIssue?: number | undefined;
    description?: string | undefined;
    publisher?: string | undefined;
    foundationDate?: Date | undefined;
    circulation?: number | undefined;
    isOpenAccess?: boolean;
    category?: string | undefined;
    targetAudience?: string | undefined;
    isPeerReviewed?: boolean | undefined;
    isIndexedInRINTS?: boolean | undefined;
    isIndexedInScopus?: boolean | undefined;
    isIndexedInWebOfScience?: boolean | undefined;
    publicationDate?: Date | undefined;
    pageCount?: number | undefined;
    coverImageUrl?: string | undefined;
    shelfId?: number;
    position?: number;
}

export class JournalPositionDto implements IJournalPositionDto {
    shelfId!: number;
    position!: number;

    constructor(data?: IJournalPositionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shelfId = _data["shelfId"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): JournalPositionDto {
        data = typeof data === 'object' ? data : {};
        let result = new JournalPositionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shelfId"] = this.shelfId;
        data["position"] = this.position;
        return data;
    }
}

export interface IJournalPositionDto {
    shelfId: number;
    position: number;
}

export class JournalUpdateDto implements IJournalUpdateDto {
    id?: number;
    title?: string | undefined;
    issn?: string | undefined;
    registrationNumber?: string | undefined;
    format?: string | undefined;
    periodicity?: string | undefined;
    pagesPerIssue?: number | undefined;
    description?: string | undefined;
    publisher?: string | undefined;
    foundationDate?: Date | undefined;
    circulation?: number | undefined;
    isOpenAccess?: boolean;
    category?: string | undefined;
    targetAudience?: string | undefined;
    isPeerReviewed?: boolean | undefined;
    isIndexedInRINTS?: boolean | undefined;
    isIndexedInScopus?: boolean | undefined;
    isIndexedInWebOfScience?: boolean | undefined;
    publicationDate?: Date | undefined;
    pageCount?: number | undefined;
    coverImageUrl?: string | undefined;

    constructor(data?: IJournalUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.issn = _data["issn"];
            this.registrationNumber = _data["registrationNumber"];
            this.format = _data["format"];
            this.periodicity = _data["periodicity"];
            this.pagesPerIssue = _data["pagesPerIssue"];
            this.description = _data["description"];
            this.publisher = _data["publisher"];
            this.foundationDate = _data["foundationDate"] ? new Date(_data["foundationDate"].toString()) : <any>undefined;
            this.circulation = _data["circulation"];
            this.isOpenAccess = _data["isOpenAccess"];
            this.category = _data["category"];
            this.targetAudience = _data["targetAudience"];
            this.isPeerReviewed = _data["isPeerReviewed"];
            this.isIndexedInRINTS = _data["isIndexedInRINTS"];
            this.isIndexedInScopus = _data["isIndexedInScopus"];
            this.isIndexedInWebOfScience = _data["isIndexedInWebOfScience"];
            this.publicationDate = _data["publicationDate"] ? new Date(_data["publicationDate"].toString()) : <any>undefined;
            this.pageCount = _data["pageCount"];
            this.coverImageUrl = _data["coverImageUrl"];
        }
    }

    static fromJS(data: any): JournalUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new JournalUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["issn"] = this.issn;
        data["registrationNumber"] = this.registrationNumber;
        data["format"] = this.format;
        data["periodicity"] = this.periodicity;
        data["pagesPerIssue"] = this.pagesPerIssue;
        data["description"] = this.description;
        data["publisher"] = this.publisher;
        data["foundationDate"] = this.foundationDate ? this.foundationDate.toISOString() : <any>undefined;
        data["circulation"] = this.circulation;
        data["isOpenAccess"] = this.isOpenAccess;
        data["category"] = this.category;
        data["targetAudience"] = this.targetAudience;
        data["isPeerReviewed"] = this.isPeerReviewed;
        data["isIndexedInRINTS"] = this.isIndexedInRINTS;
        data["isIndexedInScopus"] = this.isIndexedInScopus;
        data["isIndexedInWebOfScience"] = this.isIndexedInWebOfScience;
        data["publicationDate"] = this.publicationDate ? this.publicationDate.toISOString() : <any>undefined;
        data["pageCount"] = this.pageCount;
        data["coverImageUrl"] = this.coverImageUrl;
        return data;
    }
}

export interface IJournalUpdateDto {
    id?: number;
    title?: string | undefined;
    issn?: string | undefined;
    registrationNumber?: string | undefined;
    format?: string | undefined;
    periodicity?: string | undefined;
    pagesPerIssue?: number | undefined;
    description?: string | undefined;
    publisher?: string | undefined;
    foundationDate?: Date | undefined;
    circulation?: number | undefined;
    isOpenAccess?: boolean;
    category?: string | undefined;
    targetAudience?: string | undefined;
    isPeerReviewed?: boolean | undefined;
    isIndexedInRINTS?: boolean | undefined;
    isIndexedInScopus?: boolean | undefined;
    isIndexedInWebOfScience?: boolean | undefined;
    publicationDate?: Date | undefined;
    pageCount?: number | undefined;
    coverImageUrl?: string | undefined;
}

export class ReservationCreateDto implements IReservationCreateDto {
    id?: string;
    userId?: string;
    bookId?: string;
    reservationDate?: Date;
    expirationDate?: Date;
    status?: string | undefined;
    notes?: string | undefined;

    constructor(data?: IReservationCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.bookId = _data["bookId"];
            this.reservationDate = _data["reservationDate"] ? new Date(_data["reservationDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): ReservationCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReservationCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["bookId"] = this.bookId;
        data["reservationDate"] = this.reservationDate ? this.reservationDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IReservationCreateDto {
    id?: string;
    userId?: string;
    bookId?: string;
    reservationDate?: Date;
    expirationDate?: Date;
    status?: string | undefined;
    notes?: string | undefined;
}

export class ReservationDto implements IReservationDto {
    id?: string;
    userId?: string;
    bookId?: string;
    reservationDate?: Date;
    expirationDate?: Date;
    status?: string | undefined;
    notes?: string | undefined;

    constructor(data?: IReservationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.bookId = _data["bookId"];
            this.reservationDate = _data["reservationDate"] ? new Date(_data["reservationDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): ReservationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReservationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["bookId"] = this.bookId;
        data["reservationDate"] = this.reservationDate ? this.reservationDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IReservationDto {
    id?: string;
    userId?: string;
    bookId?: string;
    reservationDate?: Date;
    expirationDate?: Date;
    status?: string | undefined;
    notes?: string | undefined;
}

export class ReservationUpdateDto implements IReservationUpdateDto {
    id?: string;
    userId?: string;
    bookId?: string;
    reservationDate?: Date;
    expirationDate?: Date;
    status?: string | undefined;
    notes?: string | undefined;

    constructor(data?: IReservationUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.bookId = _data["bookId"];
            this.reservationDate = _data["reservationDate"] ? new Date(_data["reservationDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): ReservationUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReservationUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["bookId"] = this.bookId;
        data["reservationDate"] = this.reservationDate ? this.reservationDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IReservationUpdateDto {
    id?: string;
    userId?: string;
    bookId?: string;
    reservationDate?: Date;
    expirationDate?: Date;
    status?: string | undefined;
    notes?: string | undefined;
}

export class ShelfCreateDto implements IShelfCreateDto {
    category!: string;
    capacity!: number;
    shelfNumber!: number;
    posX!: number;
    posY!: number;
    lastReorganized?: Date | undefined;

    constructor(data?: IShelfCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            this.capacity = _data["capacity"];
            this.shelfNumber = _data["shelfNumber"];
            this.posX = _data["posX"];
            this.posY = _data["posY"];
            this.lastReorganized = _data["lastReorganized"] ? new Date(_data["lastReorganized"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ShelfCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShelfCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["capacity"] = this.capacity;
        data["shelfNumber"] = this.shelfNumber;
        data["posX"] = this.posX;
        data["posY"] = this.posY;
        data["lastReorganized"] = this.lastReorganized ? this.lastReorganized.toISOString() : <any>undefined;
        return data;
    }
}

export interface IShelfCreateDto {
    category: string;
    capacity: number;
    shelfNumber: number;
    posX: number;
    posY: number;
    lastReorganized?: Date | undefined;
}

export class ShelfDto implements IShelfDto {
    id?: number;
    category?: string | undefined;
    capacity?: number;
    shelfNumber?: number;
    posX?: number;
    posY?: number;
    lastReorganized?: Date | undefined;

    constructor(data?: IShelfDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.category = _data["category"];
            this.capacity = _data["capacity"];
            this.shelfNumber = _data["shelfNumber"];
            this.posX = _data["posX"];
            this.posY = _data["posY"];
            this.lastReorganized = _data["lastReorganized"] ? new Date(_data["lastReorganized"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ShelfDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShelfDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["category"] = this.category;
        data["capacity"] = this.capacity;
        data["shelfNumber"] = this.shelfNumber;
        data["posX"] = this.posX;
        data["posY"] = this.posY;
        data["lastReorganized"] = this.lastReorganized ? this.lastReorganized.toISOString() : <any>undefined;
        return data;
    }
}

export interface IShelfDto {
    id?: number;
    category?: string | undefined;
    capacity?: number;
    shelfNumber?: number;
    posX?: number;
    posY?: number;
    lastReorganized?: Date | undefined;
}

export class ShelfUpdateDto implements IShelfUpdateDto {
    category!: string;
    capacity!: number;
    shelfNumber!: number;
    posX!: number;
    posY!: number;
    lastReorganized?: Date | undefined;

    constructor(data?: IShelfUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.category = _data["category"];
            this.capacity = _data["capacity"];
            this.shelfNumber = _data["shelfNumber"];
            this.posX = _data["posX"];
            this.posY = _data["posY"];
            this.lastReorganized = _data["lastReorganized"] ? new Date(_data["lastReorganized"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ShelfUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShelfUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["category"] = this.category;
        data["capacity"] = this.capacity;
        data["shelfNumber"] = this.shelfNumber;
        data["posX"] = this.posX;
        data["posY"] = this.posY;
        data["lastReorganized"] = this.lastReorganized ? this.lastReorganized.toISOString() : <any>undefined;
        return data;
    }
}

export interface IShelfUpdateDto {
    category: string;
    capacity: number;
    shelfNumber: number;
    posX: number;
    posY: number;
    lastReorganized?: Date | undefined;
}

export class UserCreateDto implements IUserCreateDto {
    id?: string;
    fullName?: string | undefined;
    email?: string | undefined;
    username?: string | undefined;
    isActive?: boolean;
    borrowedBooksCount?: number;
    maxBooksAllowed?: number;
    fineAmount?: number;
    dateRegistered?: Date;
    phone?: string | undefined;
    dateOfBirth?: Date;
    passportNumber?: string | undefined;
    passportIssuedBy?: string | undefined;
    passwordHash?: string | undefined;

    constructor(data?: IUserCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.isActive = _data["isActive"];
            this.borrowedBooksCount = _data["borrowedBooksCount"];
            this.maxBooksAllowed = _data["maxBooksAllowed"];
            this.fineAmount = _data["fineAmount"];
            this.dateRegistered = _data["dateRegistered"] ? new Date(_data["dateRegistered"].toString()) : <any>undefined;
            this.phone = _data["phone"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.passportNumber = _data["passportNumber"];
            this.passportIssuedBy = _data["passportIssuedBy"];
            this.passwordHash = _data["passwordHash"];
        }
    }

    static fromJS(data: any): UserCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["username"] = this.username;
        data["isActive"] = this.isActive;
        data["borrowedBooksCount"] = this.borrowedBooksCount;
        data["maxBooksAllowed"] = this.maxBooksAllowed;
        data["fineAmount"] = this.fineAmount;
        data["dateRegistered"] = this.dateRegistered ? this.dateRegistered.toISOString() : <any>undefined;
        data["phone"] = this.phone;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["passportNumber"] = this.passportNumber;
        data["passportIssuedBy"] = this.passportIssuedBy;
        data["passwordHash"] = this.passwordHash;
        return data;
    }
}

export interface IUserCreateDto {
    id?: string;
    fullName?: string | undefined;
    email?: string | undefined;
    username?: string | undefined;
    isActive?: boolean;
    borrowedBooksCount?: number;
    maxBooksAllowed?: number;
    fineAmount?: number;
    dateRegistered?: Date;
    phone?: string | undefined;
    dateOfBirth?: Date;
    passportNumber?: string | undefined;
    passportIssuedBy?: string | undefined;
    passwordHash?: string | undefined;
}

export class UserDto implements IUserDto {
    id?: string;
    fullName?: string | undefined;
    email?: string | undefined;
    username?: string | undefined;
    isActive?: boolean;
    borrowedBooksCount?: number;
    maxBooksAllowed?: number;
    fineAmount?: number;
    dateRegistered?: Date;
    phone?: string | undefined;
    dateOfBirth?: Date;
    passportNumber?: string | undefined;
    passportIssuedBy?: string | undefined;
    passwordHash?: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.isActive = _data["isActive"];
            this.borrowedBooksCount = _data["borrowedBooksCount"];
            this.maxBooksAllowed = _data["maxBooksAllowed"];
            this.fineAmount = _data["fineAmount"];
            this.dateRegistered = _data["dateRegistered"] ? new Date(_data["dateRegistered"].toString()) : <any>undefined;
            this.phone = _data["phone"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.passportNumber = _data["passportNumber"];
            this.passportIssuedBy = _data["passportIssuedBy"];
            this.passwordHash = _data["passwordHash"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["username"] = this.username;
        data["isActive"] = this.isActive;
        data["borrowedBooksCount"] = this.borrowedBooksCount;
        data["maxBooksAllowed"] = this.maxBooksAllowed;
        data["fineAmount"] = this.fineAmount;
        data["dateRegistered"] = this.dateRegistered ? this.dateRegistered.toISOString() : <any>undefined;
        data["phone"] = this.phone;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["passportNumber"] = this.passportNumber;
        data["passportIssuedBy"] = this.passportIssuedBy;
        data["passwordHash"] = this.passwordHash;
        return data;
    }
}

export interface IUserDto {
    id?: string;
    fullName?: string | undefined;
    email?: string | undefined;
    username?: string | undefined;
    isActive?: boolean;
    borrowedBooksCount?: number;
    maxBooksAllowed?: number;
    fineAmount?: number;
    dateRegistered?: Date;
    phone?: string | undefined;
    dateOfBirth?: Date;
    passportNumber?: string | undefined;
    passportIssuedBy?: string | undefined;
    passwordHash?: string | undefined;
}

export class UserUpdateDto implements IUserUpdateDto {
    id?: string;
    fullName?: string | undefined;
    email?: string | undefined;
    username?: string | undefined;
    isActive?: boolean;
    borrowedBooksCount?: number;
    maxBooksAllowed?: number;
    fineAmount?: number;
    dateRegistered?: Date;
    phone?: string | undefined;
    dateOfBirth?: Date;
    passportNumber?: string | undefined;
    passportIssuedBy?: string | undefined;
    passwordHash?: string | undefined;

    constructor(data?: IUserUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.isActive = _data["isActive"];
            this.borrowedBooksCount = _data["borrowedBooksCount"];
            this.maxBooksAllowed = _data["maxBooksAllowed"];
            this.fineAmount = _data["fineAmount"];
            this.dateRegistered = _data["dateRegistered"] ? new Date(_data["dateRegistered"].toString()) : <any>undefined;
            this.phone = _data["phone"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.passportNumber = _data["passportNumber"];
            this.passportIssuedBy = _data["passportIssuedBy"];
            this.passwordHash = _data["passwordHash"];
        }
    }

    static fromJS(data: any): UserUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["email"] = this.email;
        data["username"] = this.username;
        data["isActive"] = this.isActive;
        data["borrowedBooksCount"] = this.borrowedBooksCount;
        data["maxBooksAllowed"] = this.maxBooksAllowed;
        data["fineAmount"] = this.fineAmount;
        data["dateRegistered"] = this.dateRegistered ? this.dateRegistered.toISOString() : <any>undefined;
        data["phone"] = this.phone;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["passportNumber"] = this.passportNumber;
        data["passportIssuedBy"] = this.passportIssuedBy;
        data["passwordHash"] = this.passwordHash;
        return data;
    }
}

export interface IUserUpdateDto {
    id?: string;
    fullName?: string | undefined;
    email?: string | undefined;
    username?: string | undefined;
    isActive?: boolean;
    borrowedBooksCount?: number;
    maxBooksAllowed?: number;
    fineAmount?: number;
    dateRegistered?: Date;
    phone?: string | undefined;
    dateOfBirth?: Date;
    passportNumber?: string | undefined;
    passportIssuedBy?: string | undefined;
    passwordHash?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}